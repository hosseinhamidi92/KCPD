
#%% 
from numpy import concatenate, linspace
from numpy.random import normal
from scipy.stats import gaussian_kde, entropy, ks_2samp
import matplotlib.pyplot as plt
import scienceplots

plt.style.use('science')


MAX_ENTROPY_ALLOWED = 1e6  # A hack to never deal with inf entropy values that happen when the PDFs don't intersect


def run_test(p_samples, q_samples, p_label="P", q_label="Q"):
    n1 = len(p_samples)
    n2 = len(q_samples)
    if n1 == 0 or n2 == 0:
        return 0

    # Plot the samples
    # with plt.style.context('science'):
    plt.figure()
    # Normalize p_samples and q_samples between 0 and 1
    # p_samples = (p_samples - min(p_samples)) / (max(p_samples) - min(p_samples))
    # q_samples = (q_samples - min(q_samples)) / (max(q_samples) - min(q_samples))

    plt.hist(p_samples, bins=25, color='b', alpha=0.5, label=p_label)
    plt.hist(q_samples, bins=25, color='g', alpha=0.5, label=q_label)
    # plt.legend(loc="upper right")
    plt.show()

    # Estimate the PDFs using Gaussian KDE
    pdf1 = gaussian_kde(p_samples)
    pdf2 = gaussian_kde(q_samples)

    # Calculate the interval to be analyzed further
    a = min(min(p_samples), min(q_samples))
    b = max(max(p_samples), max(q_samples))

    # Plot the PDFs
    lin = linspace(a, b, max(n1, n2))
    p = pdf1.pdf(lin)
    q = pdf2.pdf(lin)
    # with plt.style.context('science'):
    plt.figure()
    plt.plot(lin, p, color='b', label="Estimated PDF(P)")
    plt.plot(lin, q, color='g', label="Estimated PDF(Q)")
    # plt.legend(loc="upper right")
    plt.show()

    # Return the Kullback-Leibler divergence
    return min(MAX_ENTROPY_ALLOWED, entropy(p, q))


def run_normal_unimodal(n1=1000, n2=1000, mu1=0., sigma1=1., mu2=0., sigma2=1.):
    s1 = normal(mu1, sigma1, n1)
    s2 = normal(mu2, sigma2, n2)

    label1 = "P ~ N(%.2f, %.2f), %d samples" % (mu1, sigma1, n1)
    label2 = "Q ~ N(%.2f, %.2f), %d samples" % (mu2, sigma2, n2)
    kl_div = run_test(s1, s2, label1, label2)
    ks_test = ks_2samp(s1, s2)
    print("%s\n%s\nKL-divergence: %.10f\nKS 2-sample test: %.10f\n\n" % (label1, label2, kl_div, ks_test[0]))


def run_normal_bimodal(n1=1000, n2=1000, mu11=0., mu12=10., sigma11=1., sigma12=.5, mu2=0., sigma2=1.):
    s11 = normal(mu11, sigma11, n1)
    s12 = normal(mu12, sigma12, n1)

    s1 = concatenate((s11, s12))
    s2 = normal(mu2, sigma2, n2)

    label1 = "P ~ N(%.2f, %.2f) + N(%.2f, %.2f), %d samples" % (mu11, sigma11, mu12, sigma12, n1)
    label2 = "Q ~ N(%.2f, %.2f), %d samples" % (mu2, sigma2, n2)
    kl_div = run_test(s1, s2, label1, label2)
    ks_test = ks_2samp(s1, s2)
    print("%s\n%s\nKL-divergence: %.10f\nKS 2-sample test: %.10f\n\n" % (label1, label2, kl_div, ks_test[0]))


def main():
    run_normal_unimodal(5000, 500)
    run_normal_unimodal(mu1=2., sigma1=.5)
    run_normal_unimodal(mu1=20., sigma1=.5)
    run_normal_bimodal()


if __name__ == "__main__":
    main()
# %%

# For IKS
from scipy.stats import ks_2samp
from IKS.IKS import IKS
from collections import deque
from random import random
import numpy as np
import ruptures as rpt

# Generate non-stationary data
np.random.seed(42)
initial_length = 400
stream_length = 1500

# Initial stationary data with mean 0
initial = np.random.normal(0, 1, initial_length)

# Gradually shifting data
slope = 0.001
stream = np.array([np.random.normal(slope * i, 1) for i in range(stream_length)])

# Combine initial and stream data
combined_stream = np.concatenate((initial, stream))

# Apply Kernel Change Point Detection
algo_c = rpt.KernelCPD(kernel="rbf", min_size=10).fit(combined_stream)
result = algo_c.predict(pen=1.5)[:-1]

iks_statistics = []  # collect statistics generated by IKS
iks = IKS()
sliding = deque()  # sliding window

for val in initial:
    iks.Add((val, random()), 0)
    wrnd = (val, random())  # we only need to keep RND component for values in the sliding window
    iks.Add(wrnd, 1)
    sliding.append(wrnd)

# process sliding window
for val in combined_stream:
    iks.Remove(sliding.popleft(), 1)
    wrnd = (val, random())
    iks.Add(wrnd, 1)
    sliding.append(wrnd)

    iks_statistics.append(iks.KS())

fig, ax1 = plt.subplots()

color = 'tab:blue'

with plt.style.context('science'):

    # Assuming you have event labels data to plot
    ax1.plot(range(initial_length), initial, label='Initial data')
    ax1.plot(range(initial_length, initial_length + stream_length), stream, label='Gradually shifting')
    ax1.set_xlabel('Time')
    ax1.set_ylabel('Data', color='black')
     # Add change points as vertical lines
    for cp in result:
        ax1.axvline(x=cp, color='r', linestyle='--', label='Change Point' if cp == result[0] else "")

    ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

    ax2.set_ylabel('Event Labels', color=color)  # we already handled the x-label with ax1
    ax2.set_xlabel('Time')
    ax2.set_ylabel('IKS Statistic', color=color)
    ax2.plot(iks_statistics, label='Average IKS Statistics', color='black', linewidth = 2)
    ax2.tick_params(axis='y', labelcolor=color)

    ax2.tick_params(axis='y', labelcolor=color)

    # plt.title('Average IKS Statistics with Event Labels')
    fig.tight_layout()  # otherwise the right y-label is slightly clipped

    plt.show()

#%%

# For IKS
from scipy.stats import ks_2samp
from IKS.IKS import IKS
from collections import deque
from random import random
import numpy as np
import ruptures as rpt


# Generate non-stationary data with second shift back to original mean
np.random.seed(42)
initial_length = 400
stream_length = 1500
second_shift_length = 1500

# Initial stationary data with mean 0
initial = np.random.normal(0, 1, initial_length)

# Gradually shifting data
slope = 0.001
stream = np.array([np.random.normal(slope * i, 1) for i in range(stream_length)])

# # Sudden change in mean
# mean_shift = 1
# stream = np.random.normal(mean_shift, 1, stream_length)

# Data shifting back to original mean
second_shift = np.random.normal(-0.2, 1, second_shift_length)

# Combine initial, stream, and second shift data
combined_stream = np.concatenate((initial, stream, second_shift))

# Apply Kernel Change Point Detection
algo_c = rpt.KernelCPD(kernel="rbf", min_size=10).fit(combined_stream)
result = algo_c.predict(pen=3)[:-1]  #80

iks_statistics = []  # collect statistics generated by IKS
iks = IKS()
sliding = deque()  # sliding window

for val in initial:
    iks.Add((val, random()), 0)
    wrnd = (val, random())  # we only need to keep RND component for values in the sliding window
    iks.Add(wrnd, 1)
    sliding.append(wrnd)

# process sliding window
for val in combined_stream:
    iks.Remove(sliding.popleft(), 1)
    wrnd = (val, random())
    iks.Add(wrnd, 1)
    sliding.append(wrnd)

    iks_statistics.append(iks.KS())

fig, ax1 = plt.subplots()

color = 'tab:blue'

with plt.style.context('science'):

    # Assuming you have event labels data to plot
    ax1.plot(range(initial_length), initial, label='Initial data')
    ax1.plot(range(initial_length, initial_length + stream_length), stream, label='Gradually shifting')
    ax1.plot(range(initial_length + stream_length, initial_length + stream_length + second_shift_length), second_shift, label='Shift back to original mean')
    ax1.set_xlabel('Time')
    ax1.set_ylabel('Data', color='black')
        # Add change points as vertical lines
    for cp in result:
        ax1.axvline(x=cp, color='r', linestyle='--', label='Change Point' if cp == result[0] else "")

    # ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

    # ax2.set_ylabel('Event Labels', color=color)  # we already handled the x-label with ax1
    # ax2.set_xlabel('Time')
    # ax2.set_ylabel('IKS Statistic', color=color)
    # ax2.plot(iks_statistics, label='Average IKS Statistics', color='black', linewidth = 2)
    # ax2.tick_params(axis='y', labelcolor=color)

    # ax2.tick_params(axis='y', labelcolor=color)

    # plt.title('Average IKS Statistics with Event Labels')
    fig.tight_layout()  # otherwise the right y-label is slightly clipped

    plt.show()


#%%
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

# Generate sample data
np.random.seed(42)
analysis_data = np.random.normal(3, 1, 1000)  # Mean=3, SD=1
reference_data = np.random.normal(2.5, 1, 1000)  # Mean=2.5, SD=1

# Create figure with two subplots
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Plot 1: PDFs
x = np.linspace(-4, 8, 200)
analysis_kde = stats.gaussian_kde(analysis_data)
reference_kde = stats.gaussian_kde(reference_data)

ax1.plot(x, analysis_kde(x), label='Analysis PDF', color='purple')
ax1.plot(x, reference_kde(x), label='Reference PDF', color='purple', linestyle='--')
ax1.set_title('PDFs', fontsize=16)
ax1.set_xlabel('Value', fontsize=14)
ax1.set_ylabel('Density', fontsize=14)
ax1.legend(fontsize=12)

# Plot 2: KS Statistic
# Calculate empirical CDFs
analysis_sorted = np.sort(analysis_data)
reference_sorted = np.sort(reference_data)
analysis_cdf = np.arange(1, len(analysis_data) + 1) / len(analysis_data)
reference_cdf = np.arange(1, len(reference_data) + 1) / len(reference_data)

# Calculate KS statistic
ks_stat, p_value = stats.ks_2samp(analysis_data, reference_data)

# Plot CDFs
ax2.plot(analysis_sorted, analysis_cdf, label='Analysis CDF', color='purple')
ax2.plot(reference_sorted, reference_cdf, label='Reference CDF', color='purple', linestyle='--')

# Find point of maximum difference
# Interpolate CDFs to common x points
x_common = np.sort(np.concatenate([analysis_sorted, reference_sorted]))
analysis_cdf_interp = np.interp(x_common, analysis_sorted, analysis_cdf)
reference_cdf_interp = np.interp(x_common, reference_sorted, reference_cdf)
diff = np.abs(analysis_cdf_interp - reference_cdf_interp)
max_diff_idx = np.argmax(diff)
max_diff_x = x_common[max_diff_idx]
max_diff_y1 = analysis_cdf_interp[max_diff_idx]
max_diff_y2 = reference_cdf_interp[max_diff_idx]

# Plot max difference
ax2.plot([max_diff_x, max_diff_x], [max_diff_y1, max_diff_y2], 'r--', label='Max Diff')
ax2.plot(max_diff_x, max_diff_y1, 'ro')
ax2.plot(max_diff_x, max_diff_y2, 'ro')

ax2.set_title('Kolmogorov-Smirnov Statistic', fontsize=16)
ax2.set_xlabel('Value', fontsize=14)
ax2.set_ylabel('Cumulative Probability', fontsize=14)
ax2.legend(fontsize=12)

# Add KS statistic value
ax2.text(0.7, 0.1, f'KS Stat: {ks_stat:.2f}', 
         transform=ax2.transAxes, 
         bbox=dict(facecolor='pink', alpha=0.5), fontsize=12)

plt.tight_layout()
plt.show()

# %%
